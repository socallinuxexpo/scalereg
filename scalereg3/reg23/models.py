import datetime

from django.db import models

from common import utils

SALUTATION_CHOICES = (
    ('Mr', 'Mr.'),
    ('Ms', 'Ms.'),
    ('Mrs', 'Mrs.'),
    ('Dr', 'Dr.'),
)

PAYMENT_CHOICES = (
    ('payflow', 'Payflow'),
    ('cash', 'Cash'),
    ('invitee', 'Invitee'),
    ('exhibitor', 'Exhibitor'),
    ('speaker', 'Speaker'),
    ('press', 'Press'),
    ('freeup', 'Free Upgrade'),
)

TICKET_CHOICES = (
    ('exhibitor', 'Exhibitor'),
    ('expo', 'Expo Only'),
    ('full', 'Full'),
    ('kid', 'Kids Pass'),
    ('press', 'Press'),
    ('speaker', 'Speaker'),
    ('staff', 'Staff'),
)


class Order(models.Model):
    # basic info
    order_num = models.CharField(
        max_length=10,
        primary_key=True,
        help_text='Unique 10 upper-case letters + numbers code')
    valid = models.BooleanField(default=False)
    date = models.DateTimeField(auto_now_add=True)

    # name and address
    name = models.CharField(max_length=120)
    address = models.CharField(max_length=120)
    city = models.CharField(max_length=60)
    state = models.CharField(max_length=60)
    zip_code = models.CharField(max_length=20)
    country = models.CharField(max_length=60, blank=True)

    # contact info
    email = models.EmailField()
    phone = models.CharField(max_length=20, blank=True)

    # payment info
    amount = models.DecimalField(max_digits=6, decimal_places=2)
    payment_type = models.CharField(max_length=10, choices=PAYMENT_CHOICES)
    payflow_auth_code = models.CharField(max_length=30,
                                         blank=True,
                                         help_text='Only used by Payflow')
    payflow_pnref = models.CharField(
        max_length=15,
        blank=True,
        help_text='Payment Network Reference ID (PNREF), a number generated by '
        'Payment that uniquely identifies the transaction')
    payflow_resp_msg = models.CharField(max_length=60,
                                        blank=True,
                                        help_text='Only used by Payflow')
    payflow_result = models.CharField(max_length=60,
                                      blank=True,
                                      help_text='Only used by Payflow')
    already_paid_attendees = models.ManyToManyField(
        'Attendee',
        blank=True,
        related_name='already_paid',
        help_text='Attendees charged multiple times on this order')


class TicketManager(models.Manager):

    def get_queryset(self):
        tickets = super().get_queryset()
        today = datetime.date.today()
        exclude = [item for item in tickets if not item.is_public(today)]
        for item in exclude:
            tickets = tickets.exclude(name=item.name)
        return tickets


class Ticket(models.Model):
    name = models.CharField(
        max_length=5,
        primary_key=True,
        help_text='Up to 5 letters, upper-case letters + numbers')
    description = models.CharField(max_length=60)
    ticket_type = models.CharField(max_length=10, choices=TICKET_CHOICES)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    public = models.BooleanField(
        help_text='Publicly available on the order page')
    cash = models.BooleanField(help_text='Available for cash purchase')
    upgradable = models.BooleanField(help_text='Eligible for upgrades')
    start_date = models.DateField(null=True,
                                  blank=True,
                                  help_text='Available on this day')
    end_date = models.DateField(null=True,
                                blank=True,
                                help_text='Not Usable on this day')

    objects = models.Manager()
    public_objects = TicketManager()

    def ticket_cost(self, items, promo):
        ticket_price = self.get_promo_price(promo)
        items_price = 0
        for item in items:
            items_price += item.get_promo_price(promo)
            if item.ticket_offset:
                ticket_price = 0
        return ticket_price + items_price

    def is_public(self, date):
        if not self.public:
            return False
        if self.start_date and self.start_date > date:
            return False
        if self.end_date and self.end_date <= date:
            return False
        return True

    def get_items(self):
        items = Item.objects.filter(applies_to_all=True).filter(active=True)
        return items.union(self.item_set.filter(active=True)).order_by('name')

    def get_promo_price(self, promo):
        if promo and promo.is_applicable_to(self):
            return round(self.price * promo.price_modifier, 2)
        return self.price

    def apply_promo(self, promo):
        self.price = self.get_promo_price(promo)


class PromoCodeManager(models.Manager):

    def get_queryset(self):
        promo_codes = super().get_queryset()
        exclude = [item for item in promo_codes if not item.is_active()]
        for item in exclude:
            promo_codes = promo_codes.exclude(name=item.name)
        return promo_codes

    def names(self):
        name_list = []
        for f in self.get_queryset():
            name_list.append(f.name)
        return name_list


class PromoCode(models.Model):
    name = models.CharField(
        max_length=5,
        primary_key=True,
        help_text='Up to 5 letters, upper-case letters + numbers')
    description = models.CharField(max_length=60)

    price_modifier = models.DecimalField(
        max_digits=3,
        decimal_places=2,
        help_text='This is the price multiplier, i.e. for 0.4, $10 becomes $4.'
    )
    active = models.BooleanField(default=False)
    start_date = models.DateField(null=True,
                                  blank=True,
                                  help_text='Available on this day')
    end_date = models.DateField(null=True,
                                blank=True,
                                help_text='Not Usable on this day')
    applies_to = models.ManyToManyField(Ticket, blank=True)
    applies_to_all = models.BooleanField(default=False,
                                         help_text='Applies to all tickets')

    objects = models.Manager()
    active_objects = PromoCodeManager()

    def is_active(self):
        if not self.active:
            return False
        today = datetime.date.today()
        if self.start_date and self.start_date > today:
            return False
        if self.end_date and self.end_date <= today:
            return False
        return True

    def is_applicable_to(self, ticket):
        if self.applies_to_all:
            return True
        return ticket in self.applies_to.all()


class Item(models.Model):
    name = models.CharField(
        max_length=4,
        primary_key=True,
        help_text='Unique, up to 4 upper-case letters / numbers')
    description = models.CharField(max_length=60)
    url = models.URLField(max_length=200, blank=True, null=True)
    price = models.DecimalField(max_digits=5, decimal_places=2)
    active = models.BooleanField()
    promo = models.BooleanField(help_text='Price affected by promo code?')
    ticket_offset = models.BooleanField(help_text='Item offsets ticket price?')
    applies_to = models.ManyToManyField(Ticket, blank=True)
    applies_to_all = models.BooleanField(help_text='Applies to all tickets')

    def get_promo_price(self, promo):
        if promo and self.promo:
            return round(self.price * promo.price_modifier, 2)
        return self.price

    def apply_promo(self, promo):
        self.price = self.get_promo_price(promo)


class Answer(models.Model):
    question = models.ForeignKey('Question', on_delete=models.PROTECT)
    text = models.CharField(max_length=200)

    def __str__(self):
        return f'({self.question.id}) {self.text}'


class Question(models.Model):
    text = models.CharField(max_length=200)
    active = models.BooleanField(default=False)
    applies_to_tickets = models.ManyToManyField(Ticket, blank=True)
    applies_to_items = models.ManyToManyField(Item, blank=True)
    applies_to_all = models.BooleanField(default=False,
                                         help_text='Applies to all tickets')
    is_text_question = models.BooleanField(default=False,
                                           help_text='False for list question')
    max_length = models.IntegerField(null=True,
                                     blank=True,
                                     help_text='Only for text questions')

    def get_list_answers(self):
        assert not self.is_text_question
        return Answer.objects.filter(question=self.id).order_by('id')

    def is_applicable_to_ticket(self, ticket):
        if self.applies_to_all:
            return True
        return ticket in self.applies_to_tickets.all()

    def is_applicable_to_item(self, item):
        return item in self.applies_to_items.all()

    def __str__(self):
        type_text = 'Text' if self.is_text_question else 'List'
        return f'{type_text} Question: {self.text}'


class Attendee(models.Model):

    class EmailChoices(models.IntegerChoices):
        LOGISTICS_ONLY = 0
        ANNOUNCEMENTS = 1
        SPECIAL_OFFERS = 2

    # badge info
    badge_type = models.ForeignKey(Ticket, on_delete=models.PROTECT)
    order = models.ForeignKey(Order,
                              on_delete=models.PROTECT,
                              blank=True,
                              null=True)
    valid = models.BooleanField(default=False)
    checked_in = models.BooleanField(default=False,
                                     help_text='Only for valid attendees')

    # attendee name
    salutation = models.CharField(max_length=10,
                                  choices=SALUTATION_CHOICES,
                                  blank=True)
    first_name = models.CharField(max_length=60)
    last_name = models.CharField(max_length=60)
    title = models.CharField(max_length=60, blank=True)
    org = models.CharField(max_length=60, blank=True)

    # contact info
    email = models.EmailField()
    zip_code = models.CharField(max_length=20)
    phone = models.CharField(max_length=20, blank=True)

    # etc
    promo = models.ForeignKey(PromoCode,
                              on_delete=models.PROTECT,
                              blank=True,
                              null=True)
    ordered_items = models.ManyToManyField(Item, blank=True)
    can_email = models.IntegerField(choices=EmailChoices,
                                    default=EmailChoices.LOGISTICS_ONLY)
    answers = models.ManyToManyField(Answer, blank=True)

    def checkin_code(self):
        return f'{self.id:04d}{utils.checkin_hash(self.full_name())}'

    def full_name(self):
        return f'{self.first_name} {self.last_name}'

    def ticket_cost(self):
        return self.badge_type.ticket_cost(self.ordered_items.all(),
                                           self.promo)


class PendingOrder(models.Model):
    order_num = models.CharField(
        max_length=10,
        primary_key=True,
        help_text='Unique 10 upper-case letters + numbers code')
    attendees = models.TextField(blank=True)
    date = models.DateTimeField(auto_now_add=True)

    def attendees_list(self):
        if not self.attendees:
            return []
        return [int(x) for x in self.attendees.split(',')]


class PaymentCode(models.Model):
    code = models.CharField(
        max_length=10,
        primary_key=True,
        help_text='Unique 10 upper-case letters + numbers code')
    badge_type = models.ForeignKey(Ticket, on_delete=models.PROTECT)
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    max_attendees = models.PositiveSmallIntegerField()
